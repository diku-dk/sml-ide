<html><head><head><link rel='stylesheet' href='jquery-ui.css'></link><script src='jquery-1.9.1.js'></script><script src='jquery-ui.js'></script><script src='generated_tags.js'></script><link rel='stylesheet' href='style.css'></link><script>$(function() {   $( '#tags' ).autocomplete({    source: availableTags,    select: function(event,ui){ window.location = ui.item.value; }  });});</script></head></head><body><p><a href='str_idx.html'>Structures</a> | <td align='center'><a href='sig_idx.html'>Signatures</a></td> | <td align='right'><a href='id_idx.html'>Identifiers</a></td></p><p style='width:100%'><input id='tags' placeholder='Search' style='width:100%; margin-right:20px;'></input></p><hr /><h4>Signature <tt>PACK_WORD</tt></h4><p> Byte-level packaging of word values.</p>The PackWord&lt;N&gt;Big and PackWord&lt;N&gt;Little structures provide facilities
for packing and unpacking N-bit word elements into Word8 vectors. This
mechanism allows word values to be transmitted in binary format over
networks. The PackWord&lt;N&gt;Big structures perform big-endian packing and
unpacking, while the PackWord&lt;N&gt;Little structures perform
little-endian packing and unpacking.
<hr /><pre><b>structure PackWord32Little : PACK_WORD
</b><b>structure PackWord32Big : PACK_WORD
</b></pre><hr /><pre><b>signature</b> PACK_WORD = 
  <b>sig</b>
    <b>val</b> <a href='#bytesPerElem'>bytesPerElem</a> : int
    <b>val</b> <a href='#isBigEndian'>isBigEndian</a> : bool
    <b>val</b> <a href='#subVec'>subVec</a>  : <a href='Word8Vector.sml.html#$SWord8Vector'>Word8Vector</a>.<a href='Word8Vector.sml.html#$Tvector'>vector</a> * int -> <a href='LargeWord.sml.html#$SLargeWord'>LargeWord</a>.<a href='LargeWord.sml.html#$Tword'>word</a>
    <b>val</b> <a href='#subVecX'>subVecX</a> : <a href='Word8Vector.sml.html#$SWord8Vector'>Word8Vector</a>.<a href='Word8Vector.sml.html#$Tvector'>vector</a> * int -> <a href='LargeWord.sml.html#$SLargeWord'>LargeWord</a>.<a href='LargeWord.sml.html#$Tword'>word</a>
    <b>val</b> <a href='#subArr'>subArr</a>  : <a href='Word8Array.sml.html#$SWord8Array'>Word8Array</a>.<a href='Word8Array.sml.html#$Tarray'>array</a> * int -> <a href='LargeWord.sml.html#$SLargeWord'>LargeWord</a>.<a href='LargeWord.sml.html#$Tword'>word</a>
    <b>val</b> <a href='#subArrX'>subArrX</a> : <a href='Word8Array.sml.html#$SWord8Array'>Word8Array</a>.<a href='Word8Array.sml.html#$Tarray'>array</a> * int -> <a href='LargeWord.sml.html#$SLargeWord'>LargeWord</a>.<a href='LargeWord.sml.html#$Tword'>word</a>
    <b>val</b> <a href='#update'>update</a> : <a href='Word8Array.sml.html#$SWord8Array'>Word8Array</a>.<a href='Word8Array.sml.html#$Tarray'>array</a> * int * <a href='LargeWord.sml.html#$SLargeWord'>LargeWord</a>.<a href='LargeWord.sml.html#$Tword'>word</a> -> unit
  <b>end</b></pre><hr /><dl><dt><b>[<tt><a name='bytesPerElem'>bytesPerElem</a></tt>]</b></dt> <dd>The number of bytes per element. Most implementations
will provide several structures with values of bytesPerElem that are
small powers of two (e.g., 1, 2, 4, and 8, corresponding to N of 8,
16, 32, 64, respectively).
</dd><br /><dt><b>[<tt><a name='isBigEndian'>isBigEndian</a></tt>]</b></dt> <dd>True if the structure implements a big-endian view of
the data (most-significant byte first). Otherwise, the structure
implements a little-endian view (least-significant byte first).
</dd><br /><dt><b>[<tt><a name='subVec'>subVec (vec, i)</a></tt>]</b></dt><dt><b>[<tt><a name='subVecX'>subVecX (vec, i)</a></tt>]</b></dt> <dd>These extract the subvector
<pre>
   vec[bytesPerElem*i..bytesPerElem*(i+1)-1]
</pre>

of the vector vec and convert it into a word according to the
endianness of the structure.  The subVecX version extends the sign bit
(most significant bit) when converting the subvector to a word. The
functions raise the Subscript exception if i &lt; 0 or if
Word8Vector.length vec &lt; bytesPerElem * (i + 1).
</dd><br /><dt><b>[<tt><a name='subArr'>subArr (arr, i)</a></tt>]</b></dt><dt><b>[<tt><a name='subArrX'>subArrX (arr, i)</a></tt>]</b></dt> <dd>These extract the subarray
<pre>
   arr[bytesPerElem*i..bytesPerElem*(i+1)-1]
</pre>

of the array arr and convert it into a word according to the
endianness of the structure.  The subArrX version extends the sign bit
(most significant bit) when converting the subarray into a word. The
functions raise the Subscript exception if i &lt; 0 or if
Word8Array.length arr &lt; bytesPerElem * (i+1).
</dd><br /><dt><b>[<tt><a name='update'>update (arr, i, w)</a></tt>]</b></dt> <dd>stores the bytesPerElem low-order bytes of the
word w into the bytes bytesPerElem*i through bytesPerElem*(i+1)-1 of
the array arr, according to the structure's endianness. It raises the
Subscript exception if i &lt; 0 or if Word8Array.length arr &lt;
bytesPerElem * (i+1).
</dd><br /></dl><hr /><i>Generated by SigDoc</i></body></html>